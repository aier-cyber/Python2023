import numpy as np
import random
import itertools
# 1
# Создадим случайный массив. (Кол-во значений > разнообразность чтобы были 
# одинаковые по признаку дирихле.)
first = np.random.randint(20, size = 100)
# Чтобы в ответе выводились сначала меньшие значения, потом большие, в 
# равносильных ситуациях (чтобы [4,4,2,1,2] вывелось как [1,2,2,4,4], а не
# [1,4,4,2,2])
first = np.sort(first)
# Аналогично лекции возьмём массив уникальных элементов и массив количества 
# таких элементов
uniques, amounts = np.unique(first, return_counts=True)
# С помощью vstack объеденим два получившихся массива в один двумерный, теперь
# в х ячейке верхней строки - элемент, в х ячейке второй строки - его кол-во 
second = np.vstack((uniques,amounts))
# Теперь возьмём кол-ва уникальных элементов и отсортрируем их. Очевидно, сами
# результаты сортировать бессмысленно, поэтому сортируем по содержимому ячеек
# их номера, получая таким образом ключи, последовательно расположенные в 
# массиве по возрастанию кол-ва соответсвующих элементов
sorted_amounts = np.argsort(amounts)
# Теперь создадим /|-функцию на базе нашего соединённого массива и по ключам
# склеим нужные значения, заранее домножив их на их же количество
third = list(map(lambda x: second[1][x]*[second[0][x]], list(sorted_amounts)))
# С помощью функции chain из itertools (специально искал именно такую функцию)
# сглаживаем массив.
fourth = list(itertools.chain.from_iterable(third))
print(fourth)
# easy_way = sorted(list(first))
# print(sorted(easy_way, key = lambda x: easy_way.count(x)))

# 2

# (Как я понял, за картинку можно взять просто uint8 массив hxw.
# b = np.arange создаёт массив чисел от 0 до 255 включительно,
# затем создаётся arr размерности w_idth x h_eight, выбирающий
# из b числа и кастующий их к uint8)
h_eight = int(input())
w_idth = int(input())
b = np.arange(0,256)
arr = np.array(np.random.choice(b, (w_idth,h_eight)), dtype=np.uint8)
# С помощью np.unique получаем ответ
print(len(np.unique(arr)))

# 3

# Создадим массив из 10 чисел величины 0-5
ar = np.random.randint(5, size = 10)
# В лоб ищем ответ (сумма всех чисел поделить на количество чисел)
# Так как len возвращает целое число, и значение всех чисел в массиве - 
# целое число, кастим всё к float
print(float(ar.sum())/float(len(ar)))

# 4

# Оформим проверку на треугольник отдельной функцией, основанной на 3-х 
# значном массиве:
def is_tr(a):
    if ((a[0]+a[1] > a[2]) and (a[0]+a[2] > a[1]) and (a[1]+a[2] > a[0])):
        print(a)
# tris = np.random.randint(5, size = (6,3)) # Так можно добавить ещё тестов
tris = [[1,2,3],[4,5,6],[2,2,3],[1,2,4],[5,6,2],[1,1,1],[2,2,2]]
# Используем функцию apply_along_axis - она получает на вход функцию, ось и 
# массив, и применяет функцию по выбранной оси. Очевидно, передавать в 
# качестве функции будем is_tr
answer = np.apply_along_axis(is_tr, 1, tris)
print(answer)

#
#
#
#
#